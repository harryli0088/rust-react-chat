{"version":3,"sources":["utils/arrToStr.ts","utils/crypto/encrypt.ts","utils/crypto/genKeys.ts","utils/types.ts","utils/crypto/deriveKey.ts","utils/strToArr.ts","utils/crypto/decrypt.ts","Components/BlankAnchor.tsx","Components/Chat/Chat.tsx","Components/RenderKey/RenderKey.tsx","Components/DisplaySender/DisplaySender.tsx","Components/RenderPrivateKey/RenderPrivateKey.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["arrToStr","arr","String","fromCharCode","encrypt","plaintext","derivedKey","a","encodedText","TextEncoder","encode","initializationVector","crypto","getRandomValues","Uint8Array","window","subtle","name","iv","encryptedData","cipher","btoa","initialization_vector","generateKey","namedCurve","keyPair","exportKey","publicKey","publicKeyJwk","privateKey","privateKeyJwk","MetaEnum","deriveKey","importKey","public","length","strToArr","str","from","map","ch","charCodeAt","decrypt","message","cipherStrArray","atob","decryptedData","TextDecoder","decode","BlankAnchor","props","target","rel","children","Chat","content","senderAddr","showSenderAddr","type","renderSenderAddr","className","renderContent","useMemo","lockIcon","icon","faLock","title","faLockOpen","style","alignItems","display","flexDirection","color","marginLeft","marginRight","RenderKey","JSON","stringify","jsonWebKey","undefined","DisplaySender","useState","derivedKeyExported","setDerivedKeyExported","showDerivedKey","setShowDerivedKey","useEffect","then","catch","console","error","faKey","Fragment","faEye","faEyeSlash","onClick","RenderPrivateKey","show","setShow","App","lastDate","Date","lastSenderAddr","lastType","pingInterval","publicKeyQueue","senderData","socket","setUpSocket","setState","socketReadyState","WebSocket","process","location","pathname","replace","onopen","genKeys","send","formatPublicKeyMessage","forEach","processPublicKey","forceUpdate","addChat","readyState","clearInterval","setInterval","onmessage","processSocketMessage","onclose","breakdownSocket","close","obj","public_key","parsed","parse","data","hasOwnProperty","sender_addr","connected","meta","push","warn","date","chat","chats","state","concat","getConnectionStatus","submitMessage","e","preventDefault","input","trim","Object","entries","keys","recv_addr","newRoomSubmit","newRoomURI","encodeURIComponent","newRoom","history","this","prevProps","connectionStatus","senderDataEntries","id","m","i","onSubmit","autoFocus","onChange","value","placeholder","disabled","href","faGithub","clientPackage","version","faDoorOpen","htmlFor","cursor","checked","height","textAlign","faRust","React","Component","withRouter","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2a1b5078.chunk.js","sourcesContent":["/**\n * Convert a Uint8Array into a string, one byte at a time.\n * I tried using TextEncoder and TextDecoder, but they produced different results\n * @param arr Uint8Array\n * @returns   string encoding of the array\n */\nexport default function arrToStr(arr: Uint8Array) {\n  return String.fromCharCode(...arr)\n}","import arrToStr from \"utils/arrToStr\"\n\nexport type EncryptedMessageType = {\n  cipher: string,\n  initialization_vector: string,\n}\n\n/**\n * This function encrypts a message using a derived key.\n * I use btoa after encryption and atob before decryption to make the strings easier to display on the UI.\n * Otherwise there are soemtimes emtpy spaces that look weird.\n * @param plaintext   plaintext message\n * @param derivedKey  derived symmetric key\n * @returns           a Promise for the cipher and initialization vector message\n */\nexport default async function encrypt(\n  plaintext: string,\n  derivedKey: CryptoKey\n):Promise<EncryptedMessageType> {\n  const encodedText = new TextEncoder().encode(plaintext)\n\n  //generate a random initialization vector 12 bytes (96 bits) long\n  //https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams\n  const initializationVector = crypto.getRandomValues(new Uint8Array(12))\n  const encryptedData = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv: initializationVector\n    },\n    derivedKey,\n    encodedText\n  )\n\n  return {\n    cipher: btoa(arrToStr(new Uint8Array(encryptedData))), //convert the cipher into a string\n    initialization_vector: btoa(arrToStr(initializationVector)) //convert the initialization vector to a string\n  }\n}","/**\n * This function generates a new public-private key pair, then exports them in JSON web key format\n * Based off this tutorial https://getstream.io/blog/web-crypto-api-chat/\n * @returns a Promise for an object with public and private keys in JSON web key format\n */\nexport default async function genKeys():Promise<{\n  publicKeyJwk: JsonWebKey,\n  privateKeyJwk: JsonWebKey,\n}> {\n  const keyPair:CryptoKeyPair = await crypto.subtle.generateKey(\n    {\n      name: \"ECDH\",\n      namedCurve: \"P-256\",\n    },\n    true,\n    [\"deriveKey\", \"deriveBits\"]\n  );\n\n  const publicKeyJwk:JsonWebKey = await window.crypto.subtle.exportKey(\n    \"jwk\",\n    keyPair.publicKey\n  );\n\n  const privateKeyJwk:JsonWebKey = await window.crypto.subtle.exportKey(\n    \"jwk\",\n    keyPair.privateKey\n  );\n\n  return { publicKeyJwk, privateKeyJwk };\n}\n\n\nexport const PRIVATE_KEY_JWK_SCHEMA = {\n  \"id\": \"/PrivateKeyJwk\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"crv\": { \"const\": 'P-256' },\n    \"ext\": { \"const\": true },\n    \"key_ops\": { \"const\": [ 'deriveKey', 'deriveBits' ] },\n    \"kty\": { \"const\": 'EC' },\n    \"x\": { \"type\": \"string\", maxLength: 43, minLength: 43 },\n    \"y\": { \"type\": \"string\", maxLength: 43, minLength: 43 }\n  },\n  \"required\": [\"crv\",\"ext\",\"key_ops\",\"kty\",\"x\",\"y\"]\n}\n\nexport const PUBLIC_KEY_JWK_SCHEMA = {\n  \"id\": \"/PublicKeyJwk\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"crv\": { \"const\": 'P-256' },\n    \"ext\": { \"const\": true },\n    \"key_ops\": { \"const\": [] },\n    \"kty\": { \"const\": 'EC' },\n    \"x\": { \"type\": \"string\", maxLength: 43, minLength: 43 },\n    \"y\": { \"type\": \"string\", maxLength: 43, minLength: 43 }\n  },\n  \"required\": [\"crv\",\"ext\",\"key_ops\",\"kty\",\"x\",\"y\"]\n}\n\nexport const JWK_KEY_PAIR_SCHEMA = {\n  \"id\": \"/JwkKeyPair\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"privateKeyJwk\": {\"$ref\": \"/PrivateKeyJwk\"},\n    \"publicKeyJwk\": {\"$ref\": \"/PublicKeyJwk\"},\n  },\n  \"required\": [ \"privateKeyJwk\", \"publicKeyJwk\" ]\n}","import { EncryptedMessageType } from \"./crypto/encrypt\"\n\n\n/* Message Types */\nexport type PublicKeySendType = { //broadcast\n  public_key: JsonWebKey\n}\n\nexport type PlaintextSendType = { //broadcast\n  plaintext: string\n}\n\nexport type EncryptedSendType = EncryptedMessageType & { //targeted send\n  recv_addr: string,\n}\n\n\nexport type RecvType = {\n  sender_addr: string,\n}\n\nexport type EncryptedRecvType = RecvType & EncryptedMessageType\n\nexport enum MetaEnum {\n  connected = 0,\n  disconnected,\n}\n\nexport type MetaRecvType = RecvType & {\n  meta: MetaEnum,\n}\n\nexport type PlaintextRecvType = RecvType & {\n  plaintext: string,\n}\n\nexport type PublicKeyRecvType = RecvType & {\n  public_key: JsonWebKey,\n}\n\n\n\n\n\nexport type SenderDataType = {\n  derivedKey: CryptoKey,\n  publicKeyJwk: JsonWebKey,\n}","/**\n * This function takes in a public key and a private key from a different pair to derive\n * a symmetric cryptographic key\n * Based off this tutorial https://getstream.io/blog/web-crypto-api-chat/\n * @param publicKeyJwk  a public key in JSON web key format\n * @param privateKeyJwk a separate private key in JSON web key format\n * @returns             a derived symmetric key\n */\nexport default async function deriveKey (\n  publicKeyJwk: JsonWebKey, \n  privateKeyJwk: JsonWebKey\n):Promise<CryptoKey> {\n  /* Converts the JWK format into CryptoKey objects */\n  const publicKey:CryptoKey = await window.crypto.subtle.importKey(\n    \"jwk\",\n    publicKeyJwk,\n    {\n      name: \"ECDH\",\n      namedCurve: \"P-256\",\n    },\n    true,\n    []\n  );\n\n  const privateKey:CryptoKey = await window.crypto.subtle.importKey(\n    \"jwk\",\n    privateKeyJwk,\n    {\n      name: \"ECDH\",\n      namedCurve: \"P-256\",\n    },\n    true,\n    [\"deriveKey\", \"deriveBits\"]\n  );\n\n  /* Derive the shared symmetric key */\n  return await window.crypto.subtle.deriveKey(\n    { name: \"ECDH\", public: publicKey },\n    privateKey,\n    { name: \"AES-GCM\", length: 256 },\n    true,\n    [\"encrypt\", \"decrypt\"]\n  );\n};","/**\n * Given a string, convert it to a Uint8Array\n * @param str string\n * @returns   Uint8Array\n */\nexport default function strToArr(str: string) {\n  return Uint8Array.from([...str].map(ch => ch.charCodeAt(0)))\n}","import strToArr from \"utils/strToArr\"\nimport { EncryptedMessageType } from \"./encrypt\"\n\n/**\n * Decrypt a message using the symmetric key.\n * You should wrap this in a try/catch.\n * @param message     message object with cipher and initialization vector\n * @param derivedKey  derived symmetric key \n * @returns           Promise for decrypted plaintext message\n */\nexport default async function decrypt(\n  message: EncryptedMessageType,\n  derivedKey: CryptoKey\n) {\n  const cipherStrArray = strToArr(atob(message.cipher))\n\n  /**\n   * AES-GCM validates the integrity of the plaintext and IV without needing a Message Authentication Code\n   * https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\n   * Page 8: \"GCM protects the authenticity of the plaintext and the AAD;\n   * GCM also protects the confidentiality of the plaintext,\n   * while the AAD is left in the clear\"\n   * Page 26: \"If the output is the plaintext, then the design of the mode provides strong, but not\n   * absolute, assurance that the purported source of the data created the tag, i.e., that the\n   * plaintext and the AAD (and the IV and the tag) are authentic. Consequently, the mode\n   * also provides strong assurance that this information was not subsequently altered, either\n   * intentionally or unintentionally.\"\n   * Page 26: \"If the output is FAIL, then it is certain that at least one of the given inputs\n   * (i.e., the ciphertext, the AAD, the IV, or the tag) is not authentic.\"\n   */\n  const decryptedData = await window.crypto.subtle.decrypt(\n    {\n      name: \"AES-GCM\",\n      iv: strToArr(atob(message.initialization_vector)), //convert the iv string to an array\n    },\n    derivedKey,\n    cipherStrArray\n  )\n\n  return new TextDecoder().decode(decryptedData)\n}","import React from 'react'\n\ntype Props = React.HTMLProps<HTMLAnchorElement>\n\nconst BlankAnchor = (props:Props) => {\n  return (\n    <a {...props} target=\"_blank\" rel=\"noopener noreferrer\">\n      {props.children}\n    </a>\n  )\n}\n\nexport default BlankAnchor","import React, { useMemo } from 'react'\n\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faLock, faLockOpen } from '@fortawesome/free-solid-svg-icons'\n\nimport \"./chat.scss\"\n\nexport type ChatType = {\n  content: React.ReactNode,\n  date: Date,\n  senderAddr: string,\n  showSenderAddr: boolean,\n  type: string,\n}\n\nexport type ChatTypeType = \"encrypted\" | \"meta\" | \"plaintext\" | \"self\" //the name is kind of terrible...\n\nconst Chat = (props:ChatType) => {\n  const {\n    content,\n    senderAddr,\n    showSenderAddr,\n    type,\n  } = props\n  //TODO indicate whether this message was encrypted or not\n  \n  const renderSenderAddr = showSenderAddr ? (\n    <div className=\"sender\">{senderAddr===\"self\" ? \"You\" : senderAddr}</div>\n  ) : null\n\n  const renderContent = useMemo(() => {\n    if(type === \"encrypted\" && senderAddr!==\"self\") { //if this is an encrypted message and we did not send it\n      //if this is an encrypted message we sent, that means we encrypted it differently for each recipient\n      //so that might be too many ciphers and IVs to show\n      \n      const [cipher, initializationVector, plaintext] = content as [string, string, string]\n      return (\n        <div>\n          <pre className=\"chatPre\">{plaintext}</pre>\n          <hr/>\n\n          <pre>\n            {`Cipher: ${cipher}\\nInitialization Vector: ${initializationVector}`}\n          </pre>\n        </div>\n      )\n    }\n    else if(content) {\n      return <pre className=\"chatPre\">{content}</pre>\n    }\n    return content\n  }, [content, senderAddr, type])\n\n  const lockIcon = (() => {\n    if(type === \"encrypted\") {\n      return <FontAwesomeIcon className=\"green\" icon={faLock} title=\"This message was encrypted\"/>\n    }\n    else if(type === \"plaintext\") {\n      return <FontAwesomeIcon className=\"red\" icon={faLockOpen} title=\"This message was sent as plaintext\"/>\n    }\n  })()\n\n  if(content) { //if this message has content to show\n    return (\n      <div className=\"message-container\">\n        <div className={`message ${senderAddr} ${type}`}>\n          <div>\n            {renderSenderAddr}\n            <div style={{\n              alignItems: \"center\",\n              display: \"flex\", \n              flexDirection: senderAddr===\"self\" ? \"row-reverse\" : \"row\", \n            }}>\n              <span className=\"content\">\n                {renderContent}\n              </span>\n              <span style={{color: \"gray\", marginLeft: \"0.5em\", marginRight: \"0.5em\"}}>{lockIcon}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    )\n  }\n\n  return null\n}\n\nexport default Chat\n","import React from 'react'\n\nimport \"./renderKey.scss\"\n\ntype Props = {\n  jsonWebKey: JsonWebKey\n}\n\nconst RenderKey = (props: Props) => {\n  return <div className=\"renderKey\"><pre>{JSON.stringify(props.jsonWebKey, undefined, 2)}</pre></div>\n}\n\nexport default RenderKey","import React, { useEffect, useState } from 'react'\nimport { faEye, faEyeSlash, faKey } from '@fortawesome/free-solid-svg-icons'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\n\nimport RenderKey from 'Components/RenderKey/RenderKey'\n\nimport { SenderDataType } from 'utils/types'\n\nimport \"./displaySender.scss\"\n\n\ntype Props = SenderDataType & {\n  senderAddr: string,\n}\n\nconst DisplaySender = (props: Props) => {\n  const {\n    derivedKey,\n    publicKeyJwk,\n    senderAddr,\n  } = props\n\n  const [derivedKeyExported, setDerivedKeyExported] = useState<JsonWebKey | null>(null)\n  const [showDerivedKey, setShowDerivedKey] = useState<Boolean>(false)\n\n  useEffect(() => {\n    window.crypto.subtle.exportKey(\"jwk\",derivedKey).then(jsonWebKey => {\n      setDerivedKeyExported(jsonWebKey)\n    }).catch(console.error)\n  }, [derivedKey])\n\n  return (\n    <div className=\"displaySender blob\">\n      <div>{senderAddr}</div>\n\n      <hr/>\n\n      <div>Public Key <FontAwesomeIcon icon={faKey}/></div>\n      <RenderKey jsonWebKey={publicKeyJwk}/>\n\n      {\n        derivedKeyExported && (\n          <React.Fragment>\n            <br/>\n            <div>Derived Key <FontAwesomeIcon className=\"interact\" icon={showDerivedKey ? faEye : faEyeSlash} onClick={() => setShowDerivedKey(!showDerivedKey)}/></div>\n            {showDerivedKey && <RenderKey jsonWebKey={derivedKeyExported}/>}\n          </React.Fragment>\n        )\n      }\n    </div>\n  )\n}\n\nexport default DisplaySender","import React, { useState } from 'react'\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faEye, faEyeSlash } from '@fortawesome/free-solid-svg-icons'\n\nimport RenderKey from 'Components/RenderKey/RenderKey'\n\ntype Props = {\n  jsonWebKey: JsonWebKey\n}\n\nconst RenderPrivateKey = (props:Props) => {\n  const [show, setShow] = useState<Boolean>(false)\n\n  return (\n    <div>\n      <h4>Your Private Key <FontAwesomeIcon className=\"interact\" icon={show ? faEye : faEyeSlash} onClick={() => setShow(!show)}/></h4>\n\n      {show && <RenderKey jsonWebKey={props.jsonWebKey}/>}\n    </div>\n  )\n}\n\nexport default RenderPrivateKey","import React from 'react'\nimport { withRouter, RouteComponentProps } from \"react-router\"\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faDoorOpen, faKey, faLock, faLockOpen } from '@fortawesome/free-solid-svg-icons'\nimport { faGithub, faRust } from '@fortawesome/free-brands-svg-icons'\n\nimport clientPackage from \"../package.json\"\nimport encrypt from 'utils/crypto/encrypt'\nimport genKeys from 'utils/crypto/genKeys'\nimport {\n  EncryptedRecvType,\n  EncryptedSendType,\n  MetaEnum,\n  MetaRecvType,\n  PlaintextRecvType,\n  PlaintextSendType,\n  PublicKeyRecvType,\n  PublicKeySendType,\n  SenderDataType } from 'utils/types'\nimport deriveKey from 'utils/crypto/deriveKey'\nimport decrypt from 'utils/crypto/decrypt'\n\nimport BlankAnchor from 'Components/BlankAnchor'\nimport Chat, { ChatType, ChatTypeType } from \"Components/Chat/Chat\"\nimport DisplaySender from 'Components/DisplaySender/DisplaySender'\nimport RenderKey from 'Components/RenderKey/RenderKey'\nimport RenderPrivateKey from 'Components/RenderPrivateKey/RenderPrivateKey'\n\nimport 'App.scss'\n\ntype Props = RouteComponentProps\n\ninterface State {\n  encrypt: boolean,\n  input: string,\n  chats: ChatType[],\n  newRoom: string,\n  socketReadyState: number,\n}\n\nconst WS_SERVER_URL = process.env.REACT_APP_WS_SERVER_URL || \"ws://localhost:8080\"\n\n\nclass App extends React.Component<Props,State> {\n  //meta data trackers used to determine when to show gray label text\n  lastDate: Date = new Date()\n  lastSenderAddr: string = \"\"\n  lastType: string = \"\"\n\n  pingInterval: number = -1 //pinging is important to keep WebSocket connections alive when using AWS Elastic Beanstalk\n  privateKeyJwk: JsonWebKey\n  publicKeyJwk: JsonWebKey\n  publicKeyQueue: PublicKeyRecvType[] = [] //we may receive public keys before our own keys have finished generating. push those public keys in here to process once we're ready\n  senderData: { //this maps the sender address to the sender's data (public and derived keys)\n    [senderAddr:string]: SenderDataType\n  } = {}\n  socket: WebSocket //socket connected to the chat server\n\n  constructor(props:Props) {\n    super(props)\n\n    this.state = {\n      encrypt: true,\n      input: \"\",\n      chats: [\n        // {\n        //   content: \"testing testing 123\",\n        //   date: new Date(),\n        //   senderAddr: \"tessdadfadfadfasfsdsdasfafdfafdfasfadt\",\n        //   showSenderAddr: true,\n        //   type: \"user\",\n        // },\n      ],\n      newRoom: \"\",\n      socketReadyState: 0,\n    }\n\n    //The constructor is run twice in strict mode in development, but I don't want to set up these values yet\n    //https://reactjs.org/docs/strict-mode.html#detecting-unexpected-side-effects\n    //@ts-ignore\n    this.privateKeyJwk = null\n    //@ts-ignore\n    this.socket = null\n    //@ts-ignore\n    this.publicKeyJwk = null\n  }\n\n  componentDidMount() {\n    this.socket = this.setUpSocket() //set up the socket once we mount\n  }\n\n  componentDidUpdate(prevProps:Props) {\n    //if the URL (ie the room) has changed\n    if(prevProps.location.pathname !== this.props.location.pathname) {\n      this.breakdownSocket() //break down the current connection\n      this.socket = this.setUpSocket() //then open up a new one for the new URL\n    }\n  }\n\n  componentWillUnmount() {\n    this.breakdownSocket() //breakdown the connection before unmounting\n  }\n\n  /**\n   * Connect to the server, generate new keys, set up message handlers\n   * @returns the socket\n   */\n  setUpSocket = () => {\n    this.setState({socketReadyState: 0}) //mark that we are making a new WebSocket connection\n\n    const socket = new WebSocket( //try connecting to the server\n      WS_SERVER_URL,\n      this.props.location.pathname.replace(/\\//ig, \"-\") //pass the URL pathname as the protocol ('/' characters are replaced with '-')\n    )\n\n    socket.onopen = () => { //once we connect to the server\n      genKeys().then(({publicKeyJwk, privateKeyJwk}) => { //generate our key-pair\n        //save our keys\n        this.publicKeyJwk = publicKeyJwk\n        this.privateKeyJwk = privateKeyJwk\n\n        this.send(this.formatPublicKeyMessage()) //broadcast our public key\n\n        this.publicKeyQueue.forEach(this.processPublicKey) //process any outstanding public keys\n        this.forceUpdate() //force a re-render\n      })\n      \n\n      this.addChat( //add a meta chat indicating we've connected\n        <span>You have joined the chat room <span className=\"blob\">{this.props.location.pathname}</span></span>,\n        \"self\",\n        \"meta\"\n      )\n\n      this.setState({socketReadyState: socket.readyState}) //mark the new socket state\n\n      /* Set up pinging */\n      clearInterval(this.pingInterval) //clear the previous interval\n      this.pingInterval = window.setInterval( //set up an interval to ping the server\n        () => this.socket.send(\"\"), //send empty string\n        30000\n      )\n    }\n\n    socket.onmessage = async (message:MessageEvent<any>) => {\n      // console.log(\"MESSAGE\", message)\n      try {\n        await this.processSocketMessage(message) //process this message\n      }\n      catch(err) {\n        console.error(err)\n      }\n    }\n\n    socket.onclose = () => {\n      this.setState({socketReadyState: socket.readyState})\n      //TODO try reconnecting?\n    }\n\n    return socket\n  }\n\n  breakdownSocket = () => {\n    this.socket.close() //disconnect\n    this.senderData = {} //clear all our old key data\n  }\n\n  /**\n   * Utils function to JSON stringify and object then send it to the server\n   * @param obj any object\n   */\n  send = (obj: Object) => {\n    this.socket.send(JSON.stringify(obj))\n  }\n\n  /**\n   * @returns the public key in the right format to send to the server\n   */\n  formatPublicKeyMessage = ():PublicKeySendType => ({public_key: this.publicKeyJwk})\n\n  /**\n   * Process a message from a socket\n   * @param message socket message\n   */\n  processSocketMessage = async (message:MessageEvent) => {\n    const parsed = JSON.parse(message.data) //try parsing the message as JSON\n\n    //TODO validate schema\n    if(parsed.hasOwnProperty(\"cipher\")) { //if this is an encrypted message\n      const message = parsed as EncryptedRecvType\n\n      this.addChat(\n        [\n          message.cipher,\n          message.initialization_vector,\n          await decrypt(message, this.senderData[message.sender_addr].derivedKey)\n        ],\n        message.sender_addr,\n        \"encrypted\"\n      ) //add the chat to state\n\n      //TODO queue?\n    }\n    else if(parsed.hasOwnProperty(\"meta\")) { //if this is a meta broadcast\n      const message = parsed as MetaRecvType\n\n      const connected = message.meta===MetaEnum.connected\n      this.addChat( //add the chat to state\n        `Client ${message.sender_addr} ${connected?\"\":\"dis\"}connected`,\n        message.sender_addr, \n        \"meta\"\n      )\n\n      if(connected) { //if this client just connected\n        this.send(this.formatPublicKeyMessage()) //broadcast the public key, TODO targeted send\n      }\n      else {\n        delete this.senderData[message.sender_addr] //delete this client's key data\n      }\n    }\n    else if(parsed.hasOwnProperty(\"plaintext\")) { //if this is a plaintext broadcast\n      const message = parsed as PlaintextRecvType\n\n      this.addChat(message.plaintext, message.sender_addr, \"plaintext\") //add the chat to state\n    }\n    else if(parsed.hasOwnProperty(\"public_key\")) { //if this is a public key broadcast\n      const message = parsed as PublicKeyRecvType\n\n      if(this.privateKeyJwk) { //if my private key is ready\n        await this.processPublicKey(message) //process this private key\n      }\n      else { //else I need to wait for my private key to finish generating\n        this.publicKeyQueue.push(message) //save this message to be processed later\n      }\n    }\n    else {\n      console.warn(\"Unexpected message\", parsed)\n    }\n\n    this.setState({ //update the socket state\n      socketReadyState: this.socket.readyState,\n    })\n  }\n\n  /**\n   * Given a public key message, save the public key for this sender and derived the symmetric key\n   * @param message parsed public key message\n   */\n  processPublicKey = async (message: PublicKeyRecvType) => {\n    const { public_key, sender_addr } = message\n\n    this.senderData[sender_addr] = { //assign the data to this sender\n      derivedKey: await deriveKey(public_key, this.privateKeyJwk), //derive the symmetric key\n      publicKeyJwk: public_key, //record the public key\n    }\n\n    this.addChat( //add the chat to state\n      `Received Client ${sender_addr}'s public key`,\n      sender_addr, \n      \"meta\"\n    )\n  }\n\n  /**\n   * Add a new chat to the state with meta data (time stamp, whether to show the sender name)\n   * @param content     content to display\n   * @param senderAddr  the sender address\n   * @param type        the message type\n   */\n  addChat = (content: React.ReactNode, senderAddr:string, type: ChatTypeType) => {\n    const date = new Date() //get the timestamp\n    const chat:ChatType = {\n      content,\n      date,\n      senderAddr,\n      showSenderAddr: ( //whether we should show the sender addr\n        this.lastSenderAddr !== senderAddr //if this sender is different\n        || this.lastType !== type //if the message type is different\n      ),\n      type,\n    }\n\n    //record last values\n    this.lastDate = date\n    this.lastSenderAddr = chat.senderAddr\n    this.lastType = chat.type\n\n    this.setState({ //add the chat to state\n      chats: this.state.chats.concat(chat),\n    })\n  }\n\n  /**\n   * Convert the socket ready state code to a string\n   * @returns a string representation of the socket state\n   */\n  getConnectionStatus = () => {\n    switch(this.state.socketReadyState) {\n      case 0:\n        return \"Connecting\"\n      case 1:\n        return \"Connected\"\n      case 2:\n        return \"Closing\"\n      default:\n        return \"Closed\"\n    }\n  }\n\n  /**\n   * Callback function to submit and possibly encrypt the message to the server\n   * @param e submit event\n   */\n  submitMessage = (e:React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault()\n\n    const input = this.state.input.trim() //trim the input of any white space\n    if(input) { //if there is input to send\n      if(this.state.encrypt) { //if we want to encrypt\n        Object.entries(this.senderData).forEach(async ([senderAddr,keys]) => { //encrypt the message for all recipients\n          const content:EncryptedSendType = {\n            ...(await encrypt(input, keys.derivedKey)), //encrypt the data\n            recv_addr: senderAddr //specify the intended recipient\n          }\n          this.send(content) //send the chat to the socket\n        })\n      }\n      else {\n        const content:PlaintextSendType = { plaintext: input }\n        this.send(content) //send the chat to the socket\n      }\n\n\n      this.addChat(input, \"self\", this.state.encrypt?\"encrypted\":\"plaintext\") //add this chat to our own state\n\n      this.setState({ input: \"\" }) //clear the input\n    }\n  }\n\n  /**\n   * Callback function to move to a new room\n   * @param e submit event\n   */\n  newRoomSubmit = (e:React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault()\n\n    const newRoomURI = encodeURIComponent(this.state.newRoom) //URI encode the inputed string\n\n    this.props.history.push(newRoomURI) //go to the new URL (ie change rooms)\n  }\n\n  render() {\n    const {\n      encrypt\n    } = this.state\n\n    const connectionStatus = this.getConnectionStatus()\n    \n    const senderDataEntries = Object.entries(this.senderData)\n\n    return (\n      <div id=\"App\">\n        <div id=\"main\">\n          <div id=\"content\">\n            <div id=\"header\">\n              Current Room: <span  className=\"blob\">{this.props.location.pathname}</span> <span className={`blob  ${connectionStatus}`}>{connectionStatus}</span>\n            </div>\n\n            <div id=\"chat-container\">\n              <div>\n                {this.state.chats.map((m,i) =>\n                  <Chat key={i} {...m}/>\n                )}\n              </div>\n            </div>\n\n            <div id=\"chat-form-container\">\n              <form id=\"chat-form\" onSubmit={this.submitMessage}>\n                <input\n                  autoFocus\n                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => this.setState({input: e.target.value})}\n                  placeholder=\"Aa\"\n                  value={this.state.input}\n                />\n\n                <button type=\"submit\" disabled={this.state.socketReadyState !== 1}>Send</button>\n              </form>\n            </div>\n          </div>\n\n          <div id=\"sidebar\">\n            <h2>\n              End-to-End Encrypted React - Rust Chat App &nbsp;\n              <BlankAnchor href=\"https://github.com/harryli0088/rust-react-chat\">\n                <FontAwesomeIcon className=\"interact\" icon={faGithub} style={{color: \"white\"}}/>\n              </BlankAnchor>\n            </h2>\n            <p>Version {clientPackage.version}</p>\n            <p>I created this chat room prototype to learn how to use Rust and about end-to-end encryption.</p>\n            <p id=\"disclaimer\"><b>DISCLAIMER:</b> This is probably not a cyrptographically secure system and has not been validated by security experts. This is just a side project for me to learn about end-to-end encryption.</p>\n            <p>(Note: Heroku free tier server takes several seconds to wake up from sleep mode)</p>\n            \n            <hr/>\n\n            <form id=\"new-room-form\" onSubmit={this.newRoomSubmit}>\n              {/* <h3 style={{display: \"inline-block\"}}><label htmlFor=\"new-room-input\">Change Rooms:</label></h3> &nbsp; */}\n              <input\n                id=\"new-room-input\"\n                onChange={(e: React.ChangeEvent<HTMLInputElement>) => this.setState({newRoom: e.target.value})}\n                placeholder=\"Pick a new room name\"\n                value={this.state.newRoom}\n              />&nbsp;\n\n              <button type=\"submit\">Change Rooms<FontAwesomeIcon icon={faDoorOpen}/></button>\n            </form>\n\n            <hr/>\n\n            <div style={{display: \"flex\", alignItems: \"center\"}}>\n              <label htmlFor=\"toggle-encrypt\" style={{cursor: \"pointer\"}}>Encrypt Messages:</label> &nbsp;\n              <input\n                id=\"toggle-encrypt\"\n                type=\"checkbox\"\n                checked={encrypt}\n                onChange={() => this.setState({encrypt: !encrypt})} style={{height: \"1em\"}}\n              />\n            </div>\n            <div className={`blob ${encrypt?\"green\":\"red\"}`} style={{textAlign: \"center\"}}>\n              Your messages will {encrypt===false && \"not\"} be encrypted &nbsp;\n              <FontAwesomeIcon icon={encrypt ? faLock : faLockOpen}/>\n            </div>\n\n            {\n              this.publicKeyJwk && (\n                <React.Fragment>\n                  <h4>Your Public Key <FontAwesomeIcon icon={faKey}/></h4>\n                  <RenderKey jsonWebKey={this.publicKeyJwk}/>\n                  <br/>\n                </React.Fragment>\n              )\n            }\n\n            {this.privateKeyJwk && <RenderPrivateKey jsonWebKey={this.privateKeyJwk}/>}\n\n            <hr/>\n\n            <div>\n              <h3>Connected Clients</h3>\n              \n              {\n                senderDataEntries.length > 0\n                ? (\n                  senderDataEntries.map(([senderAddr, {publicKeyJwk, derivedKey}]) =>\n                    <DisplaySender key={senderAddr} derivedKey={derivedKey} publicKeyJwk={publicKeyJwk} senderAddr={senderAddr}/>\n                  )\n                ) : <div>There are no other connected clients</div>\n              }\n            </div>\n          </div>\n        </div>\n\n        <div id=\"description\" className=\"container\">\n          <h2>Rust Overview <FontAwesomeIcon icon={faRust}/></h2>\n          <p>The Rust server features include:</p>\n          <ul>\n            <li>WebSocket server</li>\n            <li>Chat rooms via routes (via WebSocket protocol)</li>\n            <li>Alerts when a client connects or disconnects</li>\n            <li>Broadcast or targeted messages</li>\n          </ul>\n\n          <hr/>\n\n          <h2>End-to-End Encryption Overview <FontAwesomeIcon icon={faLock}/></h2>\n\n          <h3>Intro</h3>\n          <p>This is an end-to-end encrypted chat app that uses the <BlankAnchor href=\"https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto\">Subtle Web Crypto API</BlankAnchor> for encryption and sends messages to other clients via a Rust WebSocket server. I followed <BlankAnchor href=\"https://getstream.io/blog/web-crypto-api-chat/\">this Stream tutorial</BlankAnchor> to implement the encryption logic.</p>\n\n          <h3>Ephemeral Key Generation</h3>\n          <p>A client called Alice generates a public key and private key using the <BlankAnchor href=\"https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\">Elliptic Curve Diffie-Hellman (ECDH)</BlankAnchor> algorithm, which enables 2 people to share their public keys and generate a shared secret symmetric key for encryption. Alice creates these ephemeral keys when connecting to this website and deletes her keys once she disconnects.</p>\n\n          <h3>Public Key Broadcasting</h3>\n          <p>Once Alice opens this site, connects with the server, and generates a key-pair, she sends her public key to the WebSocket server. The server then broadcasts the public key to the other clients in the room. In turn, the other clients also send their public keys to Alice, so that every client has the public keys of all the other clients.</p>\n\n          <h3>Deriving a Shared Secret Symmetric Key</h3>\n          <p>When Alice receives a public key from another client Bob, Alice combines his <i>public</i> key with her own <i>private</i> key to derive a new key. Bob combines Alice's public key with his private key to also derive a new key. Because of the Diffie-Hellman algorithm, Alice and Bob actually end up separately deriving the <i>same symmetric key</i> which they can use to encrypt their messages to each other. As long as Alice and Bob protect their own private keys, it is computationally infeasible for someone else to calculate their secret symmetric key.</p>\n\n          <h3>Encryption/Decryption</h3>\n          <p>Encryption is done using the Advanced Encryption Standard - Galois/Counter Mode (<BlankAnchor href=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\">AES-GCM</BlankAnchor>) algorithm, which uses a randomly generated initialization vector to convert the plaintext message into an encrypted ciphertext. When Alice wants to send an encrypted message, she encrypts the plaintext message for every separate recipient. She sends a ciphertext, the initialization vector, and the recipient address to the server, which routes the targeted message to the intended recipient.</p>\n          <p>When Bob receives an encrypted message from Alice, he uses their derived symmetric key to decrypt the message.</p>\n\n          <h3>Message Integrity</h3>\n          <p>How do we know that a malicious attacker/server Eve didn't tamper with the message in-transit, aka a <BlankAnchor href=\"https://en.wikipedia.org/wiki/Man-in-the-middle_attack\">man-in-the-middle attack</BlankAnchor>? Symmetric encryption schemes could use <BlankAnchor href=\"https://en.wikipedia.org/wiki/Message_authentication_code\">message authentication codes</BlankAnchor>. The nice thing about AES-GCM is that it handles message integrity; if Eve tampers with the message, the decryption process will probably fail (<BlankAnchor href=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\">see this document, page 26</BlankAnchor>).</p>\n          \n          <h3>Out-of-Band Verification</h3>\n          <p>How do we know that the server isn't faking the public keys? It's possible for a malicious server Eve to break the encryption by simply generating her own keys and intercepting mesages. When Alice sends her public key to Bob, Eve stores it, but then sends <i>Eve's</i> public key to Bob, pretending that it's Alice's. Eve also takes Bob's public key, but sends <i>Eve's</i> public key to Alice. In this way, Eve can intercept a message from Alice, decrypt it, then re-encrypt it to send to Bob (and vise versa). Alice and Bob would be none the wiser. It is therefore critical to validate public keys. The only way to do this is via   <BlankAnchor href=\"https://ssd.eff.org/en/module/key-verification\">out-of-band verification</BlankAnchor>. Alice and Bob need to communicate in some way outside this app and verify each other's keys (ie over the phone, QR codes, etc). Signal implements this with <BlankAnchor href=\"https://support.signal.org/hc/en-us/articles/360007060632-What-is-a-safety-number-and-why-do-I-see-that-it-changed-\">safety numbers</BlankAnchor>.</p>\n        </div>\n\n        <footer className=\"container\">\n          <div>Built using <BlankAnchor href=\"https://reactjs.org/\">React</BlankAnchor>, <BlankAnchor href=\"https://www.typescriptlang.org/\">TypeScript</BlankAnchor>, <BlankAnchor href=\"https://fontawesome.com/license\">Font Awesome</BlankAnchor>, and <BlankAnchor href=\"https://www.rust-lang.org/\">Rust</BlankAnchor></div>\n          <br/>\n          <div><BlankAnchor href=\"https://github.com/harryli0088/rust-react-chat\">Github Repo</BlankAnchor></div>\n        </footer>\n      </div>\n    );\n  }\n}\n\nexport default withRouter(App)\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'index.scss';\nimport App from 'App';\nimport reportWebVitals from 'reportWebVitals';\nimport { HashRouter } from \"react-router-dom\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <HashRouter>\n      <App />\n    </HashRouter>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}